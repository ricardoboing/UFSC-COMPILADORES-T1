1. A gram√°tica X++ √© recursiva √† esquerda? Justifique detalhadamente sua resposta.

N√£o √© recursiva √† esquerda.

Definimos formalmente nossa gram√°tica:

Seja G = (Vn, Vt, P, program), onde:

> Vn √© o conjunto de s√≠mbolos n√£o terminais da gram√°tica 
> Vt √© o conjunto de s√≠mbolos terminais da gram√°tica 
> P √© o conjunto de produ√ß√µes da gram√°tica, descritas no arquivo xcc.g4
> program √© o s√≠mbolo inicial da gram√°tica

Sejam tamb√©m:
> A, B ‚àà Vn
> V = Vn ‚à™ Vt
> Œ±, Œ≥ ‚àà V*
> Œ≤, ùõø, Œ∏ ‚àà Vt
> ‚áí+ indica uma deriva√ß√£o em um ou mais passos.
> œÜ induca um conjunto vazio.
> 'palavra' ou 'senten√ßa' indicam uma sequ√™ncia de s√≠mbolos terminais.
> ‚àÉ significa 'existe' 
> ‚àÉ! significa 'existe um √∫nico'

Sabemos que G √© recursiva √† esquerda sse ‚àÉ A ‚áí+ AŒ±.

Seja P' o conjunto das produ√ß√µes livres de recurs√£o √† esquerda. Portanto, (P - P') √© o conjunto de produ√ß√µes que pode ter recurs√£o √† esquerda.

Inicializamos P' como vazio. Analizamos cada produ√ß√£o: se ‚àÑ A ‚Üí BŒ± | Œµ (isto √©, todas as produ√ß√µes de A s√£o do tipo A ‚Üí Œ≤Œ±), adicionamos A a P':

P' = {classdecl, classbody, vardecl, constructdecl, methoddecl, methodbody, printstat, readstat, returnstat, superstat, ifstat, forstat, lvalue, alocexpression}

Analizamos cada produ√ß√£o em (P - P'): se todas as produ√ß√µes de A s√£o do tipo A ‚Üí CŒ±, onde C ‚àà P', adicionamos A a P':

P' = P' ‚à™ {atribstat, factor}

Repetindo este passo algumas vezes:

P' = P' ‚à™ {statement, statlist, unaryexpr, term, numexpression, expression}

Neste ponto (P - P') = {program, classlist, paramlist, arglist}, pois cada um destes n√£o terminais pode derivar √©psilon.

Analizamos cada produ√ß√£o em (P - P'): se  ‚àÑ A ‚Üí BŒ±, adicionamos B a P':

P' = P' ‚à™ {arglist, paramlist}

Neste ponto (P - P') = {program, classlist} 
Podemos reescrever classlist ‚Üí (classdecl)+ como classlist ‚Üí classdecl (classdecl)*, logo, adicionamos classlist a P'. Temos program ‚Üí classlist | Œµ. Como classlist ‚àà P' e  ‚àÑ A ‚Üí program Œ±, adicionamos program a P'

Como (P - P') = œÜ, ent√£o n√£o existe recurs√£o √† esquerda nesta gram√°tica.


2. A gram√°tica X++ est√° fatorada √† esquerda? Se n√£o, fatore.

Sejam f1, f2, ... fn os conjuntos FIRST das produ√ß√µes de A. Sabemos que G est√° fatorada (√† esquerda, para um s√≠mbolo) se:

‚àÄ A, f1 ‚à© f2 ‚à© ... ‚à© fn = œÜ 

logo, vamos computar os conjuntos first para cada A, come√ßando pelos triviais:

FIRST(classdecl) = {CLASS}
FIRST(classbody) = {ABRCHAVE}
FIRST(vardecl) = {INT, STRING, IDENT}
FIRST(constructdecl) = {CONSTRUCTOR}
FIRST(methoddecl) = {INT, STRING, IDENT}
FIRST(methodbody) = {ABRPAR}
FIRST(printstat) = {PRINT}
FIRST(readstat) = {READ}
FIRST(returnstat) = {RETURN}
FIRST(superstat) = {SUPER}
FIRST(ifstat) = {IF}
FIRST(forstat) = {FOR}
FIRST(lvalue) = {IDENT}
FIRST(alocexpression) = {NEW}

FIRST(classlist) = FIRST(classdecl) = {CLASS}
FIRST(paramlist) = {INT, STRING, IDENT, Œµ}
FIRST(atribstat) = FIRST(lvalue) = {IDENT}
FIRST(factor) = {INTCONSTANT, STRINGCONSTANT, NULL, ABRPAR} ‚à™ FIRST(lvalue) = {INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}

FIRST(program) = FIRST(classlist) ‚à™ {Œµ} = {CLASS, Œµ}
FIRST(unaryexpr) = {OPMAIS, OPMENOS} ‚à™ FIRST(factor) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
FIRST(term) = FIRST(unaryexpr) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
FIRST(numexpression) = FIRST(term) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
FIRST(expression) = FIRST(numexpression) = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR}
FIRST(arglist) = FIRST(expression) ‚à™ {Œµ} = {OPMAIS, OPMENOS, INTCONSTANT, STRINGCONSTANT, NULL, IDENT, ABRPAR, Œµ}

FIRST(statement) = FIRST(vardecl) ‚à™ FIRST(atribstat) ‚à™ FIRST(readstat) ‚à™ FIRST(returnstat) ‚à™ FIRST(ifstat) ‚à™ FIRST(forstat) ‚à™ {ABRCHAVE, BREAK, PTVIR}
          = {INT, STRING, IDENT} ‚à™ {IDENT} ‚à™ {READ} ‚à™ {RETURN} ‚à™ {IF} ‚à™ {FOR} ‚à™ {ABRCHAVE, BREAK, PTVIR}
          
Como podemos ver, {INT, STRING, IDENT} ‚à© {IDENT} = {IDENT} ‚â†  œÜ. Logo, a primeira e segunda produ√ß√µes de statement n√£o est√£o fatoradas. Fatoramos:

statement ‚Üí vardecl PTVIR | atribstat PTVIR

substituindo as produ√ß√µes de vardecl e atribstat:

statement ‚Üí (INT | STRING | IDENT) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |  lvalue ATR (expression | alocexpression) PTVIR

substituimos lvalue e isolamos as produ√ß√µes n√£o fatoradas (aquelas que come√ßam com IDENT):

statement ‚Üí (INT | STRING | IDENT) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
          IDENT (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR

statement ‚Üí (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
            IDENT IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
            IDENT (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR

fatorando a primeira e segunda produ√ß√µes de statement:

statement ‚Üí (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
            IDENT statementaux

statementaux ‚Üí IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR

conjuntos first das produ√ß√µes acima:
FIRST'(statement) = {INT, STRING, IDENT}
FIRST'(statementaux) = {IDENT, ABRCOL, PONTO, ATR}

logo, conseguimos fatorar estas produ√ß√µes. Continuando:

FIRST(statement) = {INT, STRING, IDENT} ‚à™ {READ} ‚à™ {RETURN} ‚à™ {IF} ‚à™ {FOR} ‚à™ {ABRCHAVE, BREAK, PTVIR}
          = {INT, STRING, IDENT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}          
FIRST(statementaux) = {IDENT, ABRCOL, PONTO, ATR}
FIRST(statlist) = FIRST(statement) = {INT, STRING, IDENT, READ, RETURN, IF, FOR, ABRCHAVE, BREAK, PTVIR}

Como j√° analisamos todas as produ√ß√µes, terminamos.

A gram√°tica fatorada fica id√™ntica √† original, exceto pelas produ√ß√µes de statement, que devem ser substituidas pelas novas:

statement ‚Üí (INT | STRING) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR | IDENT statementaux |
            readstat PTVIR | returnstat PTVIR | ifstat | forstat PTVIR | ABRCHAVE statlist FECHCHAVE | BREAK PTVIR | PTVIR;

Tamb√©m devemos adicionar as novas produ√ß√µes de statementaux:

statementaux ‚Üí IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR |
               (ABRCOL expression FECHCOL | PONTO IDENT ( ABRPAR arglist FECHPAR )?)* ATR (expression | alocexpression) PTVIR

Agora, a gram√°tica est√° fatorada √† esquerda, para um s√≠mbolo; isto √©, √© LL(1).


3. A gram√°tica X++ est√° em LL(3). Por que o 3?

LL(k) indica que a gram√°tica pode ser analizada por um analisador sint√°tico LL(k), que faz o an√°lise da esquerda pra direita (L = Left to right) e constroi a deriva√ß√£o mais √† esquerda (L = leftmost derivation), o k indica quantos s√≠mbolos √† frente o analisador ir√° verificar. 

Vamos rever alguns conceitos:
Dizemos que uma gram√°tica est√° fatorada se qualquer palavra puder ser derivada de forma determin√≠stica, isto √©, ‚àÉ! produ√ß√£o A ‚Üí Œ≤Œ±, ‚àÄ A ‚àà Vn. Ou seja, consultamos um s√≠mbolo √† frente. Por exemplo:

S ‚Üí aS | bS | c

Por√©m, este conceito pode ser extendido: podemos dizer que uma gram√°tica est√° fatorada para dois s√≠mbolos se qualquer palavra puder ser derivada de forma determin√≠stica, mas consultando dois s√≠mbolos √† frente, isto √©, ‚àÉ! produ√ß√£o A ‚Üí Œ≤ùõøŒ±, ‚àÄ A ‚àà Vn; mas podem existir outras produ√ß√µes A ‚Üí Œ≤Œ∏Œ±, Œ∏ ‚â† ùõø. Por exemplo:

S ‚Üí abS | acS | d

Ao consultar dois s√≠mbolos √† frente, podemos decidir deterministicamente qual produ√ß√£o utilizar para derivar uma palavra.

Da mesma forma, podemos extender o conceito de FIRST para dois s√≠mbolos, neste caso chamaremos de FIRST' para maior clareza. Por exemplo, para a gram√°tica acima:

FIRST'(S) = {(a, b), (a, c), (d)}

Com estas defini√ß√µes em mente, verificamos se a nossa gram√°tica √© LL(1): 

J√° vimos, na quest√£o 2, que n√£o √© LL(1), isto √©, n√£o est√° fatorada para um s√≠mbolo.

Verificamos se √© LL(2):

Computamos os conjuntos first para dois s√≠mbolos (FIRST') para cada A. Para isto, substituimos os s√≠mbolos n√£o terminais at√© obtermos dois terminais no come√ßo de cada senten√ßa (isto √©, A ‚Üí Œ≤ùõøŒ±)

program ‚Üí ((CLASS IDENT (EXTENDS IDENT)? classbody )+)?
FIRST'(program) = {(CLASS, IDENT), (Œµ)}

classlist ‚Üí (CLASS IDENT (EXTENDS IDENT)?)+
FIRST'(classlist) = {(CLASS, IDENT)

classbody ‚Üí ABRCHAVE (classlist)? (vardecl PTVIR)* (constructdecl)* (methoddecl)* FECHCHAVE

classbody ‚Üí ABRCHAVE ((classdecl)+)? ((INT | STRING | IDENT) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR)* (CONSTRUCTOR methodbody)* ( (INT | STRING | IDENT) (ABRCOL FECHCOL)* IDENT methodbody)* FECHCHAVE

classbody ‚Üí ABRCHAVE ((CLASS IDENT (EXTENDS IDENT)? classbody)+)? ((INT | STRING | IDENT) IDENT (ABRCOL FECHCOL)* (VIRG IDENT ( ABRCOL FECHCOL)*)* PTVIR)* (CONSTRUCTOR methodbody)* ( (INT | STRING | IDENT) (ABRCOL FECHCOL)* IDENT methodbody)* FECHCHAVE

FIRST'(classbody) = {(ABRCHAVE, CLASS)} ‚à™
		{(ABRCHAVE, INT), (ABRCHAVE, STRING), (ABRCHAVE IDENT)}‚à™
		{(ABRCHAVE, CONSTRUCTOR)}‚à™
		{(ABRCHAVE, INT), (ABRCHAVE, STRING), (ABRCHAVE, IDENT)} ‚à™
		{(FECHCHAVE)}

Como a interse√ß√£o dos conjuntos acima √© {(ABRCHAVE, INT), (ABRCHAVE, STRING), (ABRCHAVE, IDENT)} ‚â†  œÜ, as produ√ß√µes de classbody n√£o est√£o fatoradas para dois s√≠mbolos, portanto, esta gram√°tica n√£o √© LL(2)

Como a gram√°tica n√£o est√° fatorada √† esquerda para um s√≠mbolo nem para dois s√≠mbolos, ent√£o esta gram√°tica √© pelo menos LL(3), ou seja, √© necess√°rio verificar tr√™s s√≠mbolos √† frente para decidir deterministicamente qual produ√ß√£o utilizar para derivar uma palavra.
